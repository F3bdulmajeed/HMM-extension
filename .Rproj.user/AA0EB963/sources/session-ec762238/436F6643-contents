Rcpp::sourceCpp("src/afpop.cpp")
#source("libs/robust model set up.R")
library(Rfast)
library(zoo)



convert_bearings_to_steps.turns <- function(df) {
  if (!all(c("easting", "northing") %in% names(df))) {
    stop("Data frame must contain columns 'easting' and 'northing'")
  }
  
  x <- df$easting
  y <- df$northing
  n <- length(x)
  if (n < 3) {
    stop("At least 3 points are needed to compute turning angles")
  }
  
  step_lengths <- sqrt(diff(x)^2 + diff(y)^2)
  
  vx <- diff(x)
  vy <- diff(y)
  
  
  det_val <- vx[-length(vx)] * vy[-1] - vy[-length(vy)] * vx[-1]
  dot_val <- vx[-length(vx)] * vx[-1] + vy[-length(vy)] * vy[-1]
  
  turning_angles <- atan2(det_val, dot_val)
  
  step_lengths_full <- c(step_lengths, NA)
  turning_angles_full <- c(NA, turning_angles, NA)
  
  # Combine into data frame
  result_df <- cbind(df, "z" = step_lengths_full, "x" = turning_angles_full)
  return(as.data.frame(result_df))
}



unparameteric_estimation <- function(h,window){
  # Using non-parameteric method
  med_head <- atan2(rollmedian(sin(h), window, na.pad = TRUE, align = "center"), 
                    rollmedian(cos(h), window, na.pad = TRUE, align = "center"))
  
  # residuals of moving median filter
  errors <- na.omit((h - med_head) %% (2 * pi))
  
  sin_errors <- sin(errors)
  cos_errors <- cos(errors)
  n <- length(errors)
  # Estimate kappa for whitened_h and errors
  kappa_mu  <- vm.mle(errors)$param[2]
  est = optimise_params(errors)
  
  
  rho <- sum(sin_errors[-1] * sin_errors[-n]) / 
    sqrt(sum(sin_errors[-1]^2) * sum(sin_errors[-n]^2))
  return(c(kappa_mu , est , rho ))
}




# ── local helpers ───
adjust_range <- function(h) ((h + pi) %% (2 * pi)) - pi

kappa_from_Rbar <- function(Rbar) {
  Rbar <- pmin(pmax(Rbar, 1e-8), 0.999999)
  if (Rbar < 0.53)       2*Rbar + Rbar^3 + 5*Rbar^5/6
  else if (Rbar < 0.85) -0.4 + 1.39*Rbar + 0.43/(1 - Rbar)
  else                  1 / (Rbar^3 - 4*Rbar^2 + 3*Rbar)
}

kappa_from_angles <- function(a) {
  a <- stats::na.omit(adjust_range(a))
  if (!length(a)) return(0)
  Rbar <- sqrt(mean(sin(a))^2 + mean(cos(a))^2)
  kappa_from_Rbar(Rbar)
}

whiten_circ <- function(errors, rho) {
  e <- adjust_range(errors)
  n <- length(e)
  if (n < 2) return(numeric(0))
  se <- sin(e); ce <- cos(e)
  phi <- atan2(rho * se[-n], 1 - rho + rho * ce[-n])
  adjust_range(e[-1] - phi)
}


# ─────────────────────────────────────────────────────────────────────────────
# Single-entry wrapper that hides Rcpp symbols
# ─────────────────────────────────────────────────────────────────────────────

seg_bearing <- function(
    h,
    model,
    method,
    window = NULL,
    penalty_scale = 1,
    penalty_inflation = FALSE,
    max_rho = 0.99,
    min_rho = -0.99,
    mu_grid_len = 720
) {
  

  
  
  if(!(model %in%  c("IID", "AR", "ROB", "DROB"))){
    stop("Model is unkown")
    
  }
  

  if(!(method %in%   c("differences", "rolling"))){
    stop("Method is unkown")
    
  }
  

  h <- as.numeric(h)
  n <- length(h)
  penalty <- -penalty_scale*log(n)
  
  if (n < 3) stop("h must have length >= 3")
  

  # ── estimate rho / kappas (as in your logic) ────────────────────────────
  if (method == "differences") {
    d1 <- adjust_range(diff(h, 1))
    d2 <- adjust_range(diff(h, 2))
    num <- stats::median(1 - cos(d2), na.rm = TRUE)
    den <- stats::median(1 - cos(d1), na.rm = TRUE)
    rho <- num / den - 1
    rho <- if (is.finite(rho)) rho else 0
    rho <- min(max(rho, min_rho), max_rho)
    
    if (model %in% c("AR", "IID")) {
      kappa_rho <- 0.4592 / ((1 + rho) * (1 - sqrt(median(sin(d1))^2 + median(cos(d1))^2)))
      kappa_mu  <- (1 - rho^2) * kappa_rho
    } else {
        params   <- optimise_params(d1)
        kappa_mu <- 2 * params[1]
        est_c    <- params[2]
    }

    
  } else {
    
    med_sin  <- zoo::rollmedian(sin(h), window, na.pad = TRUE, align = "center")
    med_cos  <- zoo::rollmedian(cos(h), window, na.pad = TRUE, align = "center")
    med_head <- atan2(med_sin, med_cos)
    errors <- adjust_range(h - med_head)

    
    
    
    se <- sin(errors); ce <- cos(errors)
    idx <- which(is.finite(se) & is.finite(ce))

    rho <- sum(se[idx][-1] * se[idx][-length(idx)], na.rm = TRUE) /
      sqrt(sum(se[idx][-1]^2, na.rm = TRUE) * sum(se[idx][-length(idx)]^2, na.rm = TRUE))
    
    rho <- min(max(rho, min_rho), max_rho)
    
    if (model %in% c("AR", "IID")) {
      werr      <- whiten_circ(errors[idx], rho)
      kappa_rho <- kappa_from_angles(werr)
      kappa_mu  <- kappa_from_angles(errors[idx])
    } else {
      params    <- optimise_params(na.omit(errors))
      kappa_mu  <- params[1]
      est_c     <- params[2]
    }
  }
  
  
  # penalty inflation if requested
  if (isTRUE(penalty_inflation)) {
    penalty <- ((1 + rho) / (1 - rho)) * penalty
  }
  
  # ── dispatch to C++ in cppenv (hidden) ──────────────────────────────────
  if (model == "IID") {
    return(sort(AFPOP(h, penalty/kappa_mu)))
  }
  
  if (model == "ROB") {
    return(sort(RAFPOP(h, penalty/kappa_mu, est_c)))
  }
  
  # Build M for AR / DROB
  sin_h <- sin(h); cos_h <- cos(h)
  mu <- seq(-pi, pi, length.out = mu_grid_len)
  M <- Rfast::Outer(sin_h, sin(mu), "*") +  Rfast::Outer(cos_h, cos(mu), "*")
  
  if (model == "AR") {
    # D must have length >= n for DFPOP; pad with a trailing 0
    D <- c(cos(diff(h)), 0.0)
    return(sort(DFPOP(M, D, rho, penalty/kappa_rho)))
  }
  
  if (model == "DROB") {
    Ms <- pmax(M, est_c)
    return( sort(RDFPOP(Ms, penalty/kappa_mu)))
  }
  
  stop("Unexpected model branch.")
}




potts_algo <- function(headings , window_size , thresh){
  cosines <- cos(headings)
  sines <- sin(headings)
  x_vals <- cumsum(cosines)
  y_vals <- cumsum(sines)
  
  # Find average cos and sin over sliding window, as well as 
  # squared circular standard deviations (SCSD)
  sd_length <- length(cosines) - window_size
  ave_cos_array <- cosines[1:sd_length]/window_size
  ave_sin_array <- sines[1:sd_length]/window_size
  for(counter in 1:(window_size-1))
  {
    # Shift cosine and sin arrays back by 1
    cosines <- cosines[-1]
    sines <- sines[-1]
    ave_cos_array <- ave_cos_array + cosines[1:sd_length]/window_size
    ave_sin_array <- ave_sin_array + sines[1:sd_length]/window_size
  }
  circ_sd <- (-2)*log(sqrt((ave_sin_array)^2 + (ave_cos_array)^2))
  ave_circ_sd <- sum(circ_sd) / length(circ_sd)
  
  # Find candidate turning points by looking for spikes in SCSD
  turning <- 0
  chgpt_array <- c(1)
  for(counter in 1:length(circ_sd))
  {
    if((circ_sd[counter] > ave_circ_sd)&(turning == 0))
    {
      # Started turning.  Note turning point
      start_chgpt <- counter 
      turning <- 1
    }
    if((circ_sd[counter] < ave_circ_sd)&(turning == 1))
    {
      # Turning point is the mean of the start turning-point and the end shifted to the right by resolution/2 
      # to account for averaging being done forwards in time
      chgpt <- floor((start_chgpt + counter)/2 + window_size/2)
      chgpt_array <- c(chgpt_array,chgpt)
      turning <- 0
    }
  }
  chgpt_array <- c(chgpt_array, length(cosines))
  
  # Post processing of changepoints to remove any where the switch in direction is less than thresh_angle
  new_chgpt_array <- vector(mode="numeric", length=0)
  prev_heading <- atan2(y_vals[chgpt_array[2]]-y_vals[chgpt_array[1]],
                        x_vals[chgpt_array[2]]-x_vals[chgpt_array[1]])
  for(counter in 2:(length(chgpt_array)-1))
  {
    next_heading <- atan2(y_vals[chgpt_array[counter+1]]-y_vals[chgpt_array[counter]],
                          x_vals[chgpt_array[counter+1]]-x_vals[chgpt_array[counter]])                              
    if(abs(next_heading - prev_heading) > pi)
    {
      turn_angle <- pi*2-abs(next_heading - prev_heading)
    }
    else
    {
      turn_angle <- abs(next_heading - prev_heading)
    }
    if(turn_angle*180/pi > thresh)
    {
      new_chgpt_array <- c(new_chgpt_array, chgpt_array[counter])
      prev_heading = next_heading  
    }
  }
  
  return( c(0,new_chgpt_array, length(headings)) )
}


















# x, y: numeric vectors of equal length (trajectory)
# tps: integer indices (1-based) for inferred turning points.
#      يفضّل أن تشمل البداية والنهاية؛ وإن ما شملت، بنضيف 1 و N تلقائياً.

compute_sigma <- function(x, y, tps) {
  stopifnot(length(x) == length(y), length(x) >= 2)
  N <- length(x)
  
  # نظّف ورتّب الفهارس وتأكد أنها داخل [1, N]
  tps <- sort(unique(pmin(pmax(as.integer(tps), 1L), N)))
  if (length(tps) < 2L) tps <- unique(c(1L, N, tps))
  if (tps[1] != 1L) tps <- c(1L, tps)
  if (tps[length(tps)] != N) tps <- c(tps, N)
  
  # المسار النموذجي m(t): استيفاء خطي بين كل زوج نقاط انعطاف
  mx <- rep(NA_real_, N)
  my <- rep(NA_real_, N)
  
  for (k in seq_len(length(tps) - 1L)) {
    i0 <- tps[k]
    i1 <- tps[k + 1L]
    if (i1 <= i0) next
    idx <- i0:i1
    # نسبة التقدم بين النقطتين
    a <- (idx - i0) / (i1 - i0)
    mx[idx] <- (1 - a) * x[i0] + a * x[i1]
    my[idx] <- (1 - a) * y[i0] + a * y[i1]
  }
  
  # المتبقيّات
  rx <- x - mx
  ry <- y - my
  keep <- is.finite(rx) & is.finite(ry)
  rx <- rx[keep]; ry <- ry[keep]
  M  <- length(rx)
  if (M < 2L) stop("Not enough residuals to estimate sigma.")
  
  # تقدير sigma بافتراض ضوضاء متطابقة التباين في المحورين (σ^2 I)
  sigma_hat <- sqrt( mean(rx^2 + ry^2) / 2 )
  
  # أطوال المقاطع بين نقاط الانعطاف
  step_dx <- diff(x[tps])
  step_dy <- diff(y[tps])
  step_len <- sqrt(step_dx^2 + step_dy^2)
  step_len <- step_len[is.finite(step_len) & step_len > 0]
  if (!length(step_len)) stop("All step lengths are zero or missing.")
  
  sigma_bar <- as.numeric(sigma_hat / mean(step_len))
  
  list(
    sigma = sigma_hat,
    sigma_bar = sigma_bar,
    step_mean = mean(step_len),
    residuals = data.frame(rx = rx, ry = ry),
    model_path = data.frame(mx = mx, my = my),
    tps = tps
  )
}

## مثال استخدام:
# res <- compute_sigma(x, y, tps)
# res$sigma       # σ
# res$sigma_bar   # σ̄

