// [[Rcpp::plugins(cpp11)]]
// [[Rcpp::depends(RcppArmadillo)]]


#include <RcppArmadillo.h>
#include <cmath>
#include <limits>
#include <boost/icl/interval.hpp>
#include <boost/icl/interval_set.hpp>

using namespace Rcpp;
using boost::icl::interval;
using boost::icl::interval_set;

// ----------------- small helpers -----------------
inline double wrapToPi(double x) { return std::remainder(x, 2.0 * M_PI); }

inline interval_set<double> CreateInterval(double s, double e) {
  interval_set<double> result; result += interval<double>::closed(s, e); return result;
}
inline interval_set<double> FullCircle() { return CreateInterval(-M_PI, M_PI); }
inline interval_set<double> ComplementInCircle(const interval_set<double>& set) {
  interval_set<double> range = FullCircle(); return range - set;
}

// a*cos(mu) + b*sin(mu) + c >= z over [-pi, pi]
inline interval_set<double> solve_cosine_inequality(double a, double b, double c, double z, double R) {
  if (R == 0.0) return (c >= z) ? FullCircle() : interval_set<double>();
  const double gamma = (z - c) / R;
  if (gamma >=  1.0) return interval_set<double>();
  if (gamma <= -1.0) return FullCircle();
  const double alpha = std::atan2(a, b);
  const double delta = std::acos(gamma);
  const double lower = wrapToPi(alpha - delta);
  const double upper = wrapToPi(alpha + delta);
  if (lower < upper) return CreateInterval(lower, upper);
  if (lower > upper) return CreateInterval(-M_PI, upper) | CreateInterval(lower, M_PI);
  return FullCircle();
}

// ----------------- classes -----------------
class RCosineSegment {
public:
  interval_set<double> I; int tau; double a,b,c,R,maxima,K;
  RCosineSegment(const interval_set<double>& I_, int tau_, double a_, double b_, double c_, double K_)
    : I(I_), tau(tau_), a(a_), b(b_), c(c_), K(K_) { R = std::hypot(a,b); maxima = R + c; }
  
  inline std::vector<RCosineSegment> update(double obs, double sin_h, double cos_h,
                                            double threshold_distance,
                                            std::vector<RCosineSegment>&& vec) const {
    const double lower = wrapToPi(obs - threshold_distance);
    const double upper = wrapToPi(obs + threshold_distance);
    interval_set<double> inside_range;
    if (lower < upper) inside_range = CreateInterval(lower, upper);
    else if (lower > upper) inside_range = CreateInterval(-M_PI, upper) | CreateInterval(lower, M_PI);
    else inside_range = FullCircle();
    const interval_set<double> outside_range = ComplementInCircle(inside_range);
    
    if (!inside_range.empty()) {
      interval_set<double> valid = inside_range & I;
      if (!valid.empty()) vec.emplace_back(RCosineSegment(valid, tau, a + sin_h, b + cos_h, c, K));
    }
    if (!outside_range.empty()) {
      interval_set<double> valid = outside_range & I;
      if (!valid.empty()) vec.emplace_back(RCosineSegment(valid, tau, a, b, c + K, K));
    }
    return vec;
  }
  
  inline interval_set<double> root_finder(double z) {
    interval_set<double> feasible = solve_cosine_inequality(a, b, c, z, R);
    I = I & feasible; return I;
  }
};

class CosineSegment {
public:
  interval_set<double> I; int tau; double a,b,c,R,maxima;
  CosineSegment(const interval_set<double>& I_, int tau_, double a_, double b_, double c_)
    : I(I_), tau(tau_), a(a_), b(b_), c(c_) { R = std::hypot(a,b); maxima = R + c; }
  inline void update(double sin_h, double cos_h) { a += sin_h; b += cos_h; R = std::hypot(a,b); maxima = R + c; }
  inline interval_set<double> root_finder(double z) {
    interval_set<double> feasible = solve_cosine_inequality(a, b, c, z, R);
    I = I & feasible; return I;
  }
};

// ----------------- EXPORTS -----------------

// Robust model (RAFPOP): h -> (sin,cos) via Armadillo (vectorized).
// [[Rcpp::export]]
std::vector<int> RAFPOP(NumericVector h, double penalty, double K) {
  const R_xlen_t n = h.size();
  if (n <= 1) return std::vector<int>(1, static_cast<int>(n));
  
  // ---- vectorized sin/cos with Armadillo (zero-copy view) ----
  arma::vec h_view(const_cast<double*>(h.begin()), n, false, true);
  arma::vec sines  = arma::sin(h_view);
  arma::vec cosines = arma::cos(h_view);
  
  const interval_set<double> Range = FullCircle();
  const double threshold_distance = std::acos(K);
  
  RCosineSegment F1(Range, 0, 0.0, 0.0, 0.0, K);
  std::vector<RCosineSegment> Fs;
  Fs.reserve(4);
  Fs = F1.update(h[0], sines[0], cosines[0], threshold_distance, std::vector<RCosineSegment>());
  
  std::vector<int> last_tps(static_cast<std::size_t>(n), 0);
  double maximum = penalty;
  
  for (R_xlen_t t = 1; t < n; ++t) {
    double maxx = -std::numeric_limits<double>::infinity(); int argmaxx = -1;
    for (std::size_t j = 0; j < Fs.size(); ++j) {
      if (Fs[j].maxima > maxx) { maxx = Fs[j].maxima; argmaxx = static_cast<int>(j); }
    }
    maximum = penalty + maxx;
    last_tps[t] = Fs[argmaxx].tau;
    
    interval_set<double> Union;
    std::vector<RCosineSegment> Fs_new; Fs_new.reserve(Fs.size() + 2);
    for (std::size_t j = 0; j < Fs.size(); ++j) {
      if (!Fs[j].root_finder(maximum).empty()) {
        Union = Union | Fs[j].I;
        Fs_new = Fs[j].update(h[t], sines[t], cosines[t], threshold_distance, std::move(Fs_new));
      }
    }
    interval_set<double> new_range = ComplementInCircle(Union);
    RCosineSegment Ft(new_range, static_cast<int>(t), 0.0, 0.0, maximum, K);
    Fs_new = Ft.update(h[t], sines[t], cosines[t], threshold_distance, std::move(Fs_new));
    Fs.swap(Fs_new);
  }
  
  std::vector<int> tps; tps.reserve(static_cast<std::size_t>(n));
  tps.push_back(static_cast<int>(n));
  int last = static_cast<int>(n) - 1;
  while (last > 0) { last = last_tps[static_cast<std::size_t>(last)]; tps.push_back(last); }
  return tps;
}

// IID model (AFPOP): h -> (sin,cos) via Armadillo (vectorized).
// [[Rcpp::export]]
std::vector<int> AFPOP(NumericVector h, double penalty) {
  const R_xlen_t n = h.size();
  if (n <= 1) return std::vector<int>(1, static_cast<int>(n));
  
  arma::vec h_view(const_cast<double*>(h.begin()), n, false, true);
  arma::vec sines  = arma::sin(h_view);
  arma::vec cosines = arma::cos(h_view);
  
  const interval_set<double> Range = FullCircle();
  CosineSegment F1(Range, 0, sines[0], cosines[0], penalty);
  
  std::vector<CosineSegment> Fs; Fs.reserve(4); Fs.emplace_back(F1);
  std::vector<int> last_tps(static_cast<std::size_t>(n), 0);
  double maximum = penalty;
  
  for (R_xlen_t t = 1; t < n; ++t) {
    double maxx = -std::numeric_limits<double>::infinity(); int argmaxx = -1;
    for (std::size_t j = 0; j < Fs.size(); ++j) {
      if (Fs[j].maxima > maxx) { maxx = Fs[j].maxima; argmaxx = static_cast<int>(j); }
    }
    maximum = penalty + maxx;
    last_tps[t] = Fs[argmaxx].tau;
    
    interval_set<double> Union;
    std::vector<CosineSegment> Fs_new; Fs_new.reserve(Fs.size() + 2);
    for (std::size_t j = 0; j < Fs.size(); ++j) {
      if (!Fs[j].root_finder(maximum).empty()) {
        Union = Union | Fs[j].I;
        Fs[j].update(sines[t], cosines[t]);
        Fs_new.emplace_back(Fs[j]);
      }
    }
    interval_set<double> new_range = ComplementInCircle(Union);
    CosineSegment Ft(new_range, static_cast<int>(t), sines[t], cosines[t], maximum);
    Fs_new.emplace_back(Ft);
    Fs.swap(Fs_new);
  }
  
  std::vector<int> tps; tps.reserve(static_cast<std::size_t>(n));
  tps.push_back(static_cast<int>(n));
  int last = static_cast<int>(n) - 1;
  while (last > 0) { last = last_tps[static_cast<std::size_t>(last)]; tps.push_back(last); }
  return tps;
}

// AR(1) discretised (DFPOP): vectorized over j with Armadillo.
// [[Rcpp::export]]
std::vector<int> DFPOP(const NumericMatrix& M_in,
                       const std::vector<double>& D_in,
                       const double rho,
                       const double penalty) {
  
  const arma::mat M(const_cast<double*>(M_in.begin()), M_in.nrow(), M_in.ncol(), false, true);
  const arma::uword d = M.n_rows, n = M.n_cols;
  if (D_in.size() < n-1) stop("D must have length >= n");
  
  arma::vec curve(d, arma::fill::zeros);                 // replaces std::vector<double> curve
  std::vector<int> range(d, 0), last_tps(n, 0);
  
  const double q  = rho / (1.0 - rho);
  const double qq = 1.0 + q*q;
  const double q2 = 2.0 * q;
  
  double maximum = penalty;
  
  for (arma::uword t = 1; t < n; ++t) {
    // vectorized increment for all j
    arma::vec numerator = M.col(t) + q * D_in[t - 1];
    arma::vec denom     = arma::sqrt(qq + q2 * M.col(t - 1));
    arma::vec inc       = numerator / denom;
    
    // Apply "reset to maximum where curve <= maximum" with mask
    arma::uvec mask = arma::find(curve <= maximum);
    if (!mask.is_empty()) {
      curve.elem(mask).fill(maximum);
      // update range only for masked indices (keeps your logic)
      for (arma::uword k = 0; k < mask.n_elem; ++k) range[mask[k]] = static_cast<int>(t);
    }
    
    // Add vectorized increment
    curve += inc;
    
    // argmax
    arma::uword argmaxx = curve.index_max();
    maximum = penalty + curve[argmaxx];
    last_tps[t] = range[static_cast<std::size_t>(argmaxx)];
  }
  
  std::vector<int> tps; tps.reserve(n);
  tps.push_back(static_cast<int>(n));
  int last = static_cast<int>(n) - 1;
  while (last > 1) { last = last_tps[static_cast<std::size_t>(last-1)]; tps.push_back(last); }
  return tps;
}

// Robust discretised (RDFPOP): vectorized over j with Armadillo.
// [[Rcpp::export]]
std::vector<int> RDFPOP(const NumericMatrix& M_in, const double penalty) {
  
  const arma::mat M(const_cast<double*>(M_in.begin()), M_in.nrow(), M_in.ncol(), false, true);
  const arma::uword d = M.n_rows, n = M.n_cols;
  
  arma::vec curve(d, arma::fill::zeros);
  std::vector<int> range(d, 0), last_tps(n, 0);
  
  double maximum = penalty;
  
  for (arma::uword t = 1; t < n; ++t) {
    arma::vec inc = M.col(t - 1); // vectorized
    
    arma::uvec mask = arma::find(curve <= maximum);
    if (!mask.is_empty()) {
      curve.elem(mask).fill(maximum);
      for (arma::uword k = 0; k < mask.n_elem; ++k) range[mask[k]] = static_cast<int>(t);
    }
    
    curve += inc;
    
    arma::uword argmaxx = curve.index_max();
    maximum = penalty + curve[argmaxx];
    last_tps[t] = range[static_cast<std::size_t>(argmaxx)];
  }
  
  std::vector<int> tps; tps.reserve(n);
  tps.push_back(static_cast<int>(n));
  int last = static_cast<int>(n) - 1;
  while (last > 1) { last = last_tps[static_cast<std::size_t>(last-1)]; tps.push_back(last); }
  return tps;
}
