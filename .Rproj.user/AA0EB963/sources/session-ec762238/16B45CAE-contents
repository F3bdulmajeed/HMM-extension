library(Rcpp)
library(Rfast)
library(zoo)
sourceCpp("src/afpop.cpp")

# adjust_range <- function(h){
#   return( (h+pi)%%(2*pi)-pi)
# }
# 
# seg_bearing = function(h , model = "IID" , method = "differences", window = NULL){
#   
#   
#   if(method == "differences"){
#     rho <- median(1-cos(diff(h,2))) / median(1-cos(diff(h,1))) -1 
#     kappa_rho <- 0.4592 / ( (1+rho)*(1-sqrt( median(sin(diff(h)))^2 + median(cos(diff(h)))^2 )))
#     kappa_mu <- (1-rho^2)*kappa_rho
#   }else{
#     
#     med_head <- atan2(rollmedian(sin(h), window, na.pad = TRUE, align = "center"), 
#                       rollmedian(cos(h), window, na.pad = TRUE, align = "center"))
#     
#     errors <- na.omit((h - med_head) %% (2 * pi))
#     sin_errors <- sin(errors)
#     cos_errors <- cos(errors)
#     n <- length(errors)
#     
#     # Compute rho (autocorrelation)
#     rho <- sum(sin_errors[-1] * sin_errors[-n]) / 
#       sqrt(sum(sin_errors[-1]^2) * sum(sin_errors[-n]^2))
#     
#     # Calculate whitened errors
#     whitened_errors <- (errors[-1] - atan2(rho * sin_errors[-n], 1 - rho + rho * cos_errors[-n])) %% (2 * pi)
#     
#     # Estimate kappa for whitened_h and errors
#     kappa_rho <- vm.mle(whitened_errors)$param[2]
#     kappa_mu  <- vm.mle(errors)$param[2]
#   }
#   
#   
#   
#   
#   # fit the IID model 
#   if(model == "IID"){
#     penalty <-  -log(length(h))/kappa_mu   * (1+rho)/(1-rho)
#     tps <-  AFPOP(sin(h), cos(h), penalty) 
#   }else{
#     penalty <-  -log(length(h))/kappa_rho
#     mu <- seq(-pi,pi,  length = 720 )
#     cos_h <- cos(h) ; sin_h <- sin(h) ; cos_mu<- cos(mu) ; sin_mu<- sin(mu)
#     Msine <- Outer(sin_h , sin_mu , "*")
#     Mcosine <- Outer(cos_h , cos_mu , "*")
#     D <- cos(diff(h))
#     M <-  Msine + Mcosine
#     tps <- DFPOP(M,D,rho,penalty)
#   }
#   
#   
#   
#   
#   return(tps)
#   
# }
# 

# 
# 
# 
# convert_bearings_to_steps.turns <- function(df) {
#   if (!all(c("easting", "northing") %in% names(df))) {
#     stop("Data frame must contain columns 'easting' and 'northing'")
#   }
#   
#   x <- df$easting
#   y <- df$northing
#   n <- length(x)
#   if (n < 3) {
#     stop("At least 3 points are needed to compute turning angles")
#   }
#   
#   step_lengths <- sqrt(diff(x)^2 + diff(y)^2)
#   
#   vx <- diff(x)
#   vy <- diff(y)
#   
#   
#   det_val <- vx[-length(vx)] * vy[-1] - vy[-length(vy)] * vx[-1]
#   dot_val <- vx[-length(vx)] * vx[-1] + vy[-length(vy)] * vy[-1]
#   
#   turning_angles <- atan2(det_val, dot_val)
#   
#   step_lengths_full <- c(step_lengths, NA)           # NA at last time point (no step after last)
#   turning_angles_full <- c(NA, turning_angles, NA)   # NA for t=1 and t=n
#   
#   # Combine into data frame
#   result_df <- cbind(df, "z" = step_lengths_full, "x" = turning_angles_full)
#   return(as.data.frame(result_df))
# }
# 
